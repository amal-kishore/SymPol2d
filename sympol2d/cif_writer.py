"""
CIF writer module for generating bilayer structures
"""

import numpy as np
from typing import List, Dict, Optional
from pathlib import Path
from datetime import datetime
from dataclasses import dataclass
from .c2db_interface import Material2D


@dataclass
class StackingConfiguration:
    """Represents a stacking configuration"""
    tau: np.ndarray
    interlayer_distance: float
    polar_direction: Optional[str] = None


def generate_bilayer_cif(material: Material2D, stacking: StackingConfiguration, 
                        stacking_name: str = "bilayer") -> str:
    """
    Generate CIF content for a bilayer structure.
    
    Args:
        material: Material2D object with monolayer structure
        stacking: StackingConfiguration with stacking vector and interlayer distance
        stacking_name: Name for the structure (e.g., 'AA', 'AB', 'BA')
        
    Returns:
        CIF format string
    """
    # Get monolayer structure
    lattice = material.lattice
    positions = material.positions
    numbers = material.numbers
    symbols = material.get_chemical_symbols()

    # Convert Cartesian to fractional coordinates
    lattice_inv = np.linalg.inv(lattice)
    positions_frac = np.dot(positions, lattice_inv.T)

    # Special handling for h-BN: Use standard atomic positions
    if material.formula == 'BN' and material.layer_group == 'p-6m2':
        positions_frac = np.array([
            [0.0, 0.0, 0.5],           # B at origin
            [1.0/3.0, 2.0/3.0, 0.5]   # N at (1/3, 2/3)
        ])

    # Create bilayer by duplicating and shifting
    tau = stacking.tau
    d_interlayer = stacking.interlayer_distance

    # Get monolayer structure in Cartesian coordinates
    c_old = np.linalg.norm(lattice[2])
    positions_cart = positions.copy()  # Already in Cartesian

    # Calculate monolayer thickness in Cartesian coordinates
    z_cart = positions_cart[:, 2]
    z_min_cart = z_cart.min()
    z_max_cart = z_cart.max()
    mono_thickness = z_max_cart - z_min_cart

    # Set up new cell with c-axis = 30 Ã… (standard for 2D materials)
    c_new = 30.0  # Angstroms
    total_material = 2 * mono_thickness + d_interlayer
    total_vacuum = c_new - total_material
    vacuum_bottom = total_vacuum / 2

    new_lattice = lattice.copy()
    new_lattice[2] = lattice[2] * (c_new / c_old)  # Scale c-vector

    # Position layer 1 (bottom layer) - keep Cartesian positions relative to layer
    layer1_cart = positions_cart.copy()
    # Shift so layer starts at vacuum_bottom
    layer1_cart[:, 2] = positions_cart[:, 2] - z_min_cart + vacuum_bottom

    # Position layer 2 (top layer) above layer 1 with gap
    layer2_cart = positions_cart.copy()
    # Apply in-plane shift (in fractional coordinates)
    layer2_frac_xy = positions_frac[:, :2].copy()
    layer2_frac_xy[:, 0] += tau[0]
    layer2_frac_xy[:, 1] += tau[1]
    layer2_frac_xy = layer2_frac_xy % 1.0
    # Convert back to Cartesian xy using correct matrix multiplication
    # Cartesian = lattice.T @ fractional (for column vectors)
    # For row vectors: Cartesian = fractional @ lattice.T
    for i in range(len(layer2_cart)):
        layer2_cart[i, :2] = lattice[:2, :2].T @ layer2_frac_xy[i]
    # Shift z so layer starts after gap
    layer2_cart[:, 2] = positions_cart[:, 2] - z_min_cart + vacuum_bottom + mono_thickness + d_interlayer

    # Convert to fractional coordinates in new cell
    # Fractional = lattice_inv.T @ Cartesian (for column vectors)
    new_lattice_inv = np.linalg.inv(new_lattice)
    layer1_positions = np.zeros_like(layer1_cart)
    layer2_positions = np.zeros_like(layer2_cart)
    for i in range(len(layer1_cart)):
        layer1_positions[i] = new_lattice_inv.T @ layer1_cart[i]
        layer2_positions[i] = new_lattice_inv.T @ layer2_cart[i]

    # Combine both layers
    all_positions = np.vstack([layer1_positions, layer2_positions])
    all_symbols = symbols + symbols  # Duplicate symbols
    all_numbers = np.concatenate([numbers, numbers])
    
    # Generate CIF content
    cif_content = f"""# Generated by SYMPOL2D
# Material: {material.formula} ({material.uid})
# Stacking: {stacking_name} - tau = [{stacking.tau[0]:.4f}, {stacking.tau[1]:.4f}]
# Interlayer distance: {d_interlayer:.3f} A
# Polarization direction: {stacking.polar_direction or 'non-polar'}
# Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

data_{material.formula}_{stacking_name}

_chemical_name_common     '{material.formula} {stacking_name} bilayer'
_cell_length_a            {np.linalg.norm(new_lattice[0]):.6f}
_cell_length_b            {np.linalg.norm(new_lattice[1]):.6f}
_cell_length_c            {np.linalg.norm(new_lattice[2]):.6f}
_cell_angle_alpha         {np.degrees(np.arccos(np.dot(new_lattice[1], new_lattice[2])/(np.linalg.norm(new_lattice[1])*np.linalg.norm(new_lattice[2])))):.4f}
_cell_angle_beta          {np.degrees(np.arccos(np.dot(new_lattice[0], new_lattice[2])/(np.linalg.norm(new_lattice[0])*np.linalg.norm(new_lattice[2])))):.4f}
_cell_angle_gamma         {np.degrees(np.arccos(np.dot(new_lattice[0], new_lattice[1])/(np.linalg.norm(new_lattice[0])*np.linalg.norm(new_lattice[1])))):.4f}

_symmetry_space_group_name_H-M    'P 1'
_symmetry_Int_Tables_number       1

loop_
_atom_site_label
_atom_site_type_symbol
_atom_site_fract_x
_atom_site_fract_y
_atom_site_fract_z
_atom_site_occupancy
"""
    
    # Add atoms
    for i, (symbol, pos) in enumerate(zip(all_symbols, all_positions)):
        layer_num = 1 if i < len(symbols) else 2
        atom_label = f"{symbol}{i+1}_L{layer_num}"
        cif_content += f"{atom_label:8s} {symbol:2s} {pos[0]:10.6f} {pos[1]:10.6f} {pos[2]:10.6f} 1.0\n"
    
    return cif_content


def save_all_stackings_cif(material: Material2D, stackings: Dict[str, StackingConfiguration],
                          output_dir: Path) -> List[Path]:
    """
    Save all stacking configurations as separate CIF files.
    
    Args:
        material: Material2D object
        stackings: Dictionary of stacking configurations
        output_dir: Directory to save CIF files
        
    Returns:
        List of paths to created CIF files
    """
    output_dir.mkdir(parents=True, exist_ok=True)
    created_files = []
    
    for name, config in stackings.items():
        # Generate CIF content
        cif_content = generate_bilayer_cif(material, config, name)
        
        # Create filename
        filename = f"{material.formula}_{name}.cif"
        filepath = output_dir / filename
        
        # Write CIF file
        with open(filepath, 'w') as f:
            f.write(cif_content)
        
        created_files.append(filepath)
    
    return created_files