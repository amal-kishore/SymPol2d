"""
CIF writer module for generating bilayer structures
"""

import numpy as np
from typing import List, Dict, Optional
from pathlib import Path
from datetime import datetime
from dataclasses import dataclass
from .c2db_interface import Material2D


@dataclass
class StackingConfiguration:
    """Represents a stacking configuration"""
    tau: np.ndarray
    interlayer_distance: float
    polar_direction: Optional[str] = None


def generate_bilayer_cif(material: Material2D, stacking: StackingConfiguration, 
                        stacking_name: str = "bilayer") -> str:
    """
    Generate CIF content for a bilayer structure.
    
    Args:
        material: Material2D object with monolayer structure
        stacking: StackingConfiguration with stacking vector and interlayer distance
        stacking_name: Name for the structure (e.g., 'AA', 'AB', 'BA')
        
    Returns:
        CIF format string
    """
    # Get monolayer structure
    lattice = material.lattice
    positions = material.positions
    numbers = material.numbers
    symbols = material.get_chemical_symbols()

    # Convert Cartesian to fractional coordinates
    lattice_inv = np.linalg.inv(lattice)
    positions_frac = np.dot(positions, lattice_inv.T)

    # Special handling for h-BN: Use standard atomic positions
    if material.formula == 'BN' and material.layer_group == 'p-6m2':
        positions_frac = np.array([
            [0.0, 0.0, 0.5],           # B at origin
            [1.0/3.0, 2.0/3.0, 0.5]   # N at (1/3, 2/3)
        ])
        print("Using standard h-BN atomic positions instead of C2DB structure")

    # Create bilayer by duplicating and shifting
    tau = stacking.tau
    d_interlayer = stacking.interlayer_distance

    # Calculate monolayer thickness in Cartesian coordinates
    z_min_frac = positions_frac[:, 2].min()
    z_max_frac = positions_frac[:, 2].max()
    c_old = np.linalg.norm(lattice[2])
    mono_thickness = (z_max_frac - z_min_frac) * c_old

    # Set up new cell with proper c-axis (2*thickness + gap + vacuum)
    vacuum = 15.0  # Angstroms of vacuum
    c_new = 2 * mono_thickness + d_interlayer + vacuum
    new_lattice = lattice.copy()
    new_lattice[2] = lattice[2] * (c_new / c_old)  # Scale c-vector

    # Position layer 1 in lower part of cell (Cartesian coords)
    z_center1 = vacuum/2 + mono_thickness/2
    z_shift1 = z_center1 / c_new  # Fractional shift for layer 1
    layer1_positions = positions_frac.copy()
    # Re-center around z_shift1
    layer1_positions[:, 2] = (positions_frac[:, 2] - 0.5) + z_shift1

    # Position layer 2 above layer 1 with gap
    z_center2 = z_center1 + mono_thickness + d_interlayer
    z_shift2 = z_center2 / c_new  # Fractional shift for layer 2
    layer2_positions = positions_frac.copy()
    layer2_positions[:, 0] += tau[0]  # Shift in x (fractional)
    layer2_positions[:, 1] += tau[1]  # Shift in y (fractional)
    # Re-center around z_shift2
    layer2_positions[:, 2] = (positions_frac[:, 2] - 0.5) + z_shift2

    # Wrap xy fractional coordinates to [0, 1)
    layer2_positions[:, :2] = layer2_positions[:, :2] % 1.0

    # Combine both layers
    all_positions = np.vstack([layer1_positions, layer2_positions])
    all_symbols = symbols + symbols  # Duplicate symbols
    all_numbers = np.concatenate([numbers, numbers])
    
    # Generate CIF content
    cif_content = f"""# Generated by SYMPOL2D
# Material: {material.formula} ({material.uid})
# Stacking: {stacking_name} - tau = [{stacking.tau[0]:.4f}, {stacking.tau[1]:.4f}]
# Interlayer distance: {d_interlayer:.3f} A
# Polarization direction: {stacking.polar_direction or 'non-polar'}
# Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

data_{material.formula}_{stacking_name}

_chemical_name_common     '{material.formula} {stacking_name} bilayer'
_cell_length_a            {np.linalg.norm(new_lattice[0]):.6f}
_cell_length_b            {np.linalg.norm(new_lattice[1]):.6f}
_cell_length_c            {np.linalg.norm(new_lattice[2]):.6f}
_cell_angle_alpha         {np.degrees(np.arccos(np.dot(new_lattice[1], new_lattice[2])/(np.linalg.norm(new_lattice[1])*np.linalg.norm(new_lattice[2])))):.4f}
_cell_angle_beta          {np.degrees(np.arccos(np.dot(new_lattice[0], new_lattice[2])/(np.linalg.norm(new_lattice[0])*np.linalg.norm(new_lattice[2])))):.4f}
_cell_angle_gamma         {np.degrees(np.arccos(np.dot(new_lattice[0], new_lattice[1])/(np.linalg.norm(new_lattice[0])*np.linalg.norm(new_lattice[1])))):.4f}

_symmetry_space_group_name_H-M    'P 1'
_symmetry_Int_Tables_number       1

loop_
_atom_site_label
_atom_site_type_symbol
_atom_site_fract_x
_atom_site_fract_y
_atom_site_fract_z
_atom_site_occupancy
"""
    
    # Add atoms
    for i, (symbol, pos) in enumerate(zip(all_symbols, all_positions)):
        layer_num = 1 if i < len(symbols) else 2
        atom_label = f"{symbol}{i+1}_L{layer_num}"
        cif_content += f"{atom_label:8s} {symbol:2s} {pos[0]:10.6f} {pos[1]:10.6f} {pos[2]:10.6f} 1.0\n"
    
    return cif_content


def save_all_stackings_cif(material: Material2D, stackings: Dict[str, StackingConfiguration],
                          output_dir: Path) -> List[Path]:
    """
    Save all stacking configurations as separate CIF files.
    
    Args:
        material: Material2D object
        stackings: Dictionary of stacking configurations
        output_dir: Directory to save CIF files
        
    Returns:
        List of paths to created CIF files
    """
    output_dir.mkdir(parents=True, exist_ok=True)
    created_files = []
    
    for name, config in stackings.items():
        # Generate CIF content
        cif_content = generate_bilayer_cif(material, config, name)
        
        # Create filename
        filename = f"{material.formula}_{name}.cif"
        filepath = output_dir / filename
        
        # Write CIF file
        with open(filepath, 'w') as f:
            f.write(cif_content)
        
        created_files.append(filepath)
    
    return created_files